# KODA KB: Data Access Layers via Category Theory
_manifest:
  urn: "urn:knowledge:fxsl:cat:data-access-layers:1.0.0"
  federation: { visibility: internal, license: "CC-BY-4.0" }
  provenance: { created_by: FS, created_at: "2025-12-08" }

ID: CAT-DAL-01
Ctx: "Patrones categóricos para DAL: storage, APIs, repos, ORMs, lakes."

Storage:
  - {
      id: LIMITS-SQL,
      def: "SQL=límites (product,pullback,equalizer)",
      use: "integridad,JOINs,ACID",
    }
  - {
      id: COLIMITS-NOSQL,
      def: "NoSQL=colímites (coproduct,pushout)",
      use: "flex schema,polyglot",
    }
  - { id: MIXED-LENS, def: "SQL(write)↔Doc(read) via lens asimétrico" }

APIs:
  - {
      id: REST,
      functor: "Domain→ResourceCat",
      check: "F(id)=id,F(g∘f)=F(g)∘F(f)",
    }
  - { id: GRAPHQL, functor: "Domain→TypeCat", feature: "pullback dinámico" }
  - { id: GRPC, functor: "Domain→ProtoCat", use: "streaming,microservicios" }
  - { id: STREAMS, nature: "Coalgebra", principle: "acción=pk" }

Repository:
  structure: "Coalgebra c:X→F(X)"
  bisim: "R₁~R₂ ⟺ ∀ops.observe(R₁(ops))=observe(R₂(ops))"

ORM:
  structure: "Adjunción ORM⊣Reflect: DomainCat⇆SchemaCat"
  unit: "η:E→Reflect(ORM(E))≈id"
  counit: "ε:ORM(Reflect(T))→T≈id"
  drift: "violación η/ε=drift"

DataLake:
  construction: "colim(Dataset_i,Pipeline_ij)"
  grothendieck: "∫F, I=zonas, F(z)=schema_z"
  audit: "pipelines=morfismos; diagrama conmuta"

Synthesis:
  model: "2-cat: obj=componentes, 1-morph=transformaciones, 2-morph=migraciones"
  audit_dims:
    [
      STORAGE-MODEL-ALIGN,
      API-FUNCTOR-PRESERVE,
      REPO-BISIM,
      ORM-ADJ-VALID,
      PIPELINE-COMMUTE,
    ]
